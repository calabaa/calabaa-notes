## 06. 性能优化

1. **优化策略**:

   - 你做过哪些前端性能优化的工作？请举例说明。
     - 减少 HTTP 请求
     - 雪碧图
     - UglifyJS, 压缩代码,去除无用内容
     - 资源懒加载
     - 动态引入 vue 组件
     - 引入组件库添加按需加载
     - 较少代码体积, 纯函数, 注意代码复用
     - 合理拆分组件
   - 如何优化页面加载速度？（资源压缩合并、代码分割、按需加载、图片优化、CDN、缓存利用等）
   - 如何提升页面渲染性能？（减少 DOM 操作、合理使用 CSS、避免强制同步布局等）
   - 如何进行 JavaScript 性能优化？（防抖/节流、避免内存泄漏、优化循环等）
     - 监听页面滚动, 页面尺寸变化, 添加节流方式

2. **性能监控**:

   - 你知道哪些前端性能监控指标？
     - 白屏时间、首屏时间、LCP 最大内容绘制时间, FID 首次输入延迟,
     - CLS 累计布局偏移 , 资源加载时间
   - 使用过哪些性能分析工具？（Lighthouse, Chrome DevTools Performance/Network 面板等）
     - Lighthouse: 提供全面的性能报告
     - Performance: 性能面板,网络面板,时间轴
     - Network: 查看资源响应时间等

3. **Webpack 优化**:

   - 如何用 Webpack 的 SplitChunks 优化多入口应用的包体积？

4. **CLS 指标优化**:

   - 解释 CLS 指标优化方案，如何处理动态插入内容的布局抖动？

5. **Service Worker**:

   - 如何用 Service Worker 实现离线可用和资源预缓存？

6. **首屏渲染代码分割**:

   - 针对首屏渲染的代码分割策略（结合 React.lazy 或 Vue 异步组件）

7. **内存泄漏分析**:
   - 如何用 Performance 面板分析内存泄漏问题？

## 07. Node.js 开发（加分项）

1. **基础**:

   - Node.js 的事件循环和浏览器的事件循环有什么异同？
   - Node.js 的模块系统（CommonJS require/module.exports vs ES Modules import/export）是怎样的？
   - Node.js 如何处理异步操作？（回调函数、Promise、async/await）

2. **实践**:

   - 你使用 Node.js 做过什么？（例如：中间层、API 服务、脚手架工具等）
   - 了解 Express/Koa 等常用 Node.js 框架吗？
     - 使用 Express 开发中间层
       - 整合后端调用方法集中处理
       - 图像缓存上传, for 小程序

3. **大文件上传**:

   - 如何处理大文件上传的流式处理？
     - 分片上传

4. **事件循环阶段**:

   - 解释 Node.js 事件循环阶段，setImmediate 与 setTimeout 的执行顺序

5. **多进程服务**:

   - 如何用 Cluster 模块实现多进程服务？
     - .fork() 创建工作进程
     - on('exit') 监听进程退出

## 08. 工程化

1. **构建工具**:

   - 你常用的构建工具是什么？（Webpack/Vite）
   - 请描述一下 Webpack 的核心概念（Entry, Output, Loader, Plugin, Mode）。
   - Webpack 的打包流程是怎样的？如何优化 Webpack 的构建速度和产物体积？
   - Vite 相比 Webpack 有哪些优势？它的原理是什么？
     - 使用 rollup 打包, 直接支持 treeshaking, 代码分割、压缩优化等。
     - Vite 相比 Webpack
       - 不需要打包就能开发（基于 ESM）。
       - 热更新更快（精确模块替换）。
       - 构建更快（esbuild + Rollup）。
       - 配置更轻、更现代。

2. **代码规范与质量**:

   - 如何保证团队代码风格统一？（ESLint, Prettier）
   - 你对代码 Code Review 有什么看法？
     - 提高代码质量, 提高代码可维护性, 发现潜在问题, 提升团队成员技术

3. **CI/CD**:

   - 了解持续集成 (CI) 和持续部署 (CD) 吗？简单描述一下流程。

4. **ESLint 规则配置**:

   - 如何配置 ESLint 规则实现团队规范？prettier 集成方案

5. **自动化埋点上报系统**:

   - 设计一个自动化埋点上报系统需要考虑哪些因素？

6. **Git Hooks**:

   - 如何用 Husky 实现 Git Hooks 的代码质量拦截？
     - 创建 pre-commit 钩子 `npx husky add .husky/pre-commit "npx lint-staged"`
     - 在 package.json 文件中配置 "prepare": "husky install" (npm 安装自动执行)
     - 在 package.json 文件中配置 lint-staged `"lint-staged": {"**/*.{js,ts,tsx}": ["eslint --fix"]}`
     - 提交时会自动触发 fix 方法

7. **monorepo 架构**:

   - 解释 monorepo 架构的优势，lerna 和 pnpm workspace 的区别
     - Lerna 更适合需要强大版本控制、发布管理和多个包管理的项目，尤其是对发布流程有较高要求的场景。
     - pnpm workspace 更侧重于高效的依赖管理和性能，适合需要优化安装速度和磁盘空间的 monorepo 项目，且能够更好地避免依赖冲突。
       | 特性 | **Lerna** | **pnpm workspace** |
       |---------------------|------------------------------------|-----------------------------------|
       | **安装与依赖管理** | 使用 npm 或 yarn 来管理依赖 | 使用 pnpm 来高效管理依赖 |
       | **版本管理** | 支持 `Fixed` 和 `Independent` 版本 | 没有独立的版本管理机制 |
       | **发布管理** | 提供 `lerna publish` 功能 | 需要手动管理发布过程 |
       | **性能** | 对于大规模项目较为复杂 | 依赖管理更高效，使用硬链接减少重复 |
       | **使用场景** | 适合需要严格版本和发布管理的项目 | 适合需要高效依赖管理的项目 |

8. **组件库按需加载**:
   - 如何设计组件库的按需加载方案？

## 09. 算法题（重点准备）

1. **常见算法题**:

   - 排序
     - 小数组（<10）：推荐使用 插入排序。
     - 一般数组：使用 快速排序（现代浏览器或库内部一般用 TimSort）。
     - 需要稳定排序：优先选 归并排序 或 TimSort。
     - 数据范围有限的整数：选 计数排序 / 桶排序 / 基数排序。
     - 要求原地排序且空间敏感：快速排序 / 堆排序 更合适。

   ```js
   // 冒泡
   function bubbleSort(arr) {
     // 获取数组长度
     const n = arr.length;
     // 外层循环，控制遍历次数
     for (let i = 0; i < n - 1; i++) {
       // 内层循环，进行相邻元素比较
       for (let j = 0; j < n - 1 - i; j++) {
         // 如果前一个元素大于后一个元素，交换位置
         if (arr[j] > arr[j + 1]) {
           [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
         }
       }
     }
     // 返回排序后的数组
     return arr;
   }
   // 插入排序
   function insertionSort(arr) {
     // 从第二个元素开始遍历数组
     for (let i = 1; i < arr.length; i++) {
       // 将当前元素存储在 key 中
       // j 是已排序部分的最后一个元素的索引
       let key = arr[i],
         j = i - 1;
       // 将当前元素与已排序部分的元素进行比较
       while (j >= 0 && arr[j] > key) {
         // 如果已排序部分的元素大于当前元素，则将其向后移动一位
         arr[j + 1] = arr[j];
         // 继续向前比较
         j--;
       }
       // 将当前元素插入到正确的位置
       arr[j + 1] = key;
     }
     // 返回排序后的数组
     return arr;
   }
   /* 归并排序（Merge Sort） */
   function mergeSort(arr) {
     // 如果数组长度小于等于1，直接返回数组
     if (arr.length <= 1) return arr;
     // 计算数组中间位置
     const mid = Math.floor(arr.length / 2);
     // 递归分割左半部分
     const left = mergeSort(arr.slice(0, mid));
     // 递归分割右半部分
     const right = mergeSort(arr.slice(mid));
     // 合并左右两部分
     return merge(left, right);
   }

   // 合并两个有序数组
   function merge(left, right) {
     // 存储合并结果的数组
     const res = [];
     // 当左右数组都有元素时，进行比较
     while (left.length && right.length) {
       // 将较小的元素移入结果数组
       res.push(left[0] < right[0] ? left.shift() : right.shift());
     }
     // 合并剩余元素
     return res.concat(left, right);
   }
   ```

2. **LRU 缓存机制**:

   - 实现 LRU 缓存机制（Map+双向链表）

3. **二叉树层序遍历**:

   - 二叉树层序遍历及锯齿形输出

4. **最长递增子序列**:

   - 最长递增子序列（动态规划+二分优化）

5. **Promise 调度器**:

   - 实现 Promise 调度器（控制并发数量）

6. **解析 URL 参数**:
   - 解析 URL 参数（处理嵌套对象和数组）

## 10. 开放性问题

1. **项目**:

   - 请介绍一下你认为最有挑战性/最成功的项目，你在其中扮演了什么角色？遇到了什么困难？如何解决的？
   - 你在项目中是如何与交互设计师、视觉设计师、后端工程师协作的？
   - 你负责过通用组件/工具/平台的开发吗？能举例说明吗？

2. **学习与视野**:

   - 你平时是如何学习前端新技术的？关注哪些技术社区或博客？
   - 最近关注了哪些新的前端技术或趋势？有什么看法？

3. **态度与协作**:

   - 你认为一个优秀的前端工程师应该具备哪些素质？
   - 当你的想法和团队成员或设计师有分歧时，你会如何处理？
   - 你对加班怎么看？（谨慎回答）

4. **新技术关注**:

   - 最近关注的三个前端新技术，其核心解决了什么问题？

5. **团队代码规范**:

   - 如何推动团队代码规范的落地实施？

6. **技术方案分歧**:

   - 遇到技术方案分歧时如何处理？

7. **复杂前端问题**:

   - 展示一个你解决过的最复杂的前端问题

8. **内部工具设计**:
   - 如何设计一个提升开发效率的内部工具？

## 11. 准备建议

1. **技术原理类问题**:

   - 用"STAR"法则回答（背景-方案-成果）

2. **算法题**:

   - 重点练习高频题目，手写代码注意边界处理

3. **性能优化案例**:

   - 结合过往项目准备性能优化案例（量化指标提升）

4. **Node.js 加分项**:

   - 准备一个服务端开发案例

5. **突出重点**:

   - 根据 JD，Vue、性能优化、工程化、JS 基础是重点考察内容。

6. **结合项目**:

   - 回答问题时，尽量结合你自己的实际项目经验来谈，这样更具说服力。准备好 1-2 个可以详细介绍的项目。

7. **深入原理**:

   - 对于框架和核心 JS 知识，不仅要会用，还要能说出其设计原理。

8. **手写代码**:

   - 准备好现场手写常见算法题或 JS/Vue 相关代码片段。

9. **反问环节**:
   - 准备 1-2 个有深度的问题问面试官，体现你的思考和对公司的兴趣。
